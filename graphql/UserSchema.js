/*********************************
            JWT
/*********************************/
import { KEY } from '../config/keys'
import jwt from 'jsonwebtoken'
import bcrypt from 'bcryptjs'
/*********************************
            MODELS/GRAPHQL
/*********************************/
import User from "../models/User"
import { PostTC } from "./PostSchema"
import { TypeComposer, toInputObjectType } from 'graphql-compose';
import { composeWithMongoose, } from "graphql-compose-mongoose"
import { AuthenticationError, ApolloError } from 'apollo-server'
/*********************************
          ERRORS
/*********************************/
import { LOGIN_ERROR } from './errorMessages';

let customizationOptions = {}
export const UserTC = composeWithMongoose(User, customizationOptions);

//!DO NOT REMOVE
UserTC.removeField('password')
//! This prevents the password from autogenerated user type


const TokenTC = TypeComposer.create({ name: `Token`, fields: { token: 'String' } })
/*********************************
            RELATIONS
/*********************************/

UserTC.addRelation('posts', {
  resolver: () => PostTC.getResolver('findByIds'),
  prepareArgs: { // resolver `findByIds` has `_ids` arg, let provide value to it
    _ids: (source) => source.posts,
  },
  projection: { posts: true }
})

/*********************************
            RESOLVERS
/*********************************/

//Register
UserTC.addResolver({
  name: 'userRegister',
  type: TokenTC,
  args: {
    firstName: `String`,
    lastName: `String`,
    email: `String`,
    password: `String`
  },
  fields: {
    token: `String`,
  },
  resolve: async ({ source, args }) => {
    const userData = args
    const newUser = new User(userData)
    const user = await newUser.save().then(user => user)
    const payload = { _id: user._id, createdAt: user.createdAt, permission: user.permission }
    const expiresIn = Math.round((new Date().getTime() / 1000)) + 3600
    const token = await jwt.sign(payload, KEY, { expiresIn })
    return { token }
  }
});

//Login
UserTC.addResolver({
  name: 'userLogin',
  type: TokenTC,
  args: {
    email: `String`,
    password: `String`
  },
  fields: {
    token: `String`,

  },
  resolve: async ({ source, args }) => {
    //find user
    const user = await User.findOne({ email: args.email });
    //if not user exists throw err
    if (!user) {
      throw new ApolloError('user not found');
    }
    //compare passwords
    const isMatch = await bcrypt.compare(args.password, user.password)
    if (!isMatch) { throw new ApolloError("Password incorrect", 400) };
    const payload = { _id: user._id, createdAt: user.createdAt, permission: user.permission }
    const expiresIn = Math.round((new Date().getTime() / 1000)) + 3600
    const token = await jwt.sign(payload, KEY, { expiresIn })
    return { token }
  }
});




export const userQueries = {
  userById: UserTC.getResolver('findById'),
  userOne: UserTC.getResolver('findOne'),
  userMany: UserTC.getResolver('findMany'),
}

export const userMutations = {
  userRegister: UserTC.getResolver('userRegister'),
  userLogin: UserTC.getResolver('userLogin'),

  //TODO! protect these routes
  userUpdateById: UserTC.getResolver('updateById'),
  userRemoveById: UserTC.getResolver('removeById'),
}


